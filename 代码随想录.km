{
    "root": {
        "data": {
            "id": "cip5t7dbs940",
            "created": 1647826691098,
            "text": "目录",
            "expandState": "expand"
        },
        "children": [
            {
                "data": {
                    "id": "cip5u6lftu80",
                    "created": 1647826767776,
                    "text": "数组",
                    "expandState": "expand",
                    "layout": null
                },
                "children": [
                    {
                        "data": {
                            "id": "cip5ytiz1yg0",
                            "created": 1647827131150,
                            "text": "二分查找",
                            "note": "``` java\nif (target < nums[0] || target > nums[nums.length - 1]){\n\treturn -1;\n}\n\nint left = 0,rights = nums.length - 1\n;\n\nwhile(left<=right){\n\tint mid = left + (rights-left)/2;\n    if(nums[mid]<target){\n    \tleft = mid+1;\n    }else if(nums[mid]>target){\n    \tright = mid - 1;\n    }else {\n    \treturn mid;\n    }\n\n}\nreturn -1\n```",
                            "expandState": "expand",
                            "layout": null
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cip62377jm00",
                                    "created": 1647827387299,
                                    "text": "35 搜索插入的位置 ",
                                    "progress": 9,
                                    "expandState": "expand",
                                    "layout": null,
                                    "note": "```\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n       int len = nums.length;\n       int left = 0;\n       int right = len - 1;\n       while(left<=right){\n           int mid = left + (right - left) /2;\n           if(nums[mid]==target){\n               return mid;\n           }else if(nums[mid]<target){\n               left = mid +1;\n           }else {\n               right = mid - 1;\n           }\n       }\n       return right +1;\n    }\n}\n\n```"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cip62827tig0",
                                    "created": 1647827397881,
                                    "text": "34 在排序数组中查找元素的第一个和最后一个位置",
                                    "progress": 6,
                                    "note": "```\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int[] res = new int[]{-1,-1};\n        res[0] = binarySearch(nums,target,true);\n        res[1] = binarySearch(nums,target,false);\n        return res;\n    }\n\n    private int binarySearch(int[] nums,int target,boolean leftOrRight){\n        int res  = -1;\n        int left = 0;\n        int right = nums.length-1;\n        int mid;\n        while(left<=right){\n             mid = left+(right-left)/2;\n            if(target < nums[mid]){\n                right = mid -1;\n            }else if(target > nums[mid]){\n                left = mid +1;\n            }else{\n                res = mid;\n                if(leftOrRight){\n                    right=mid - 1;\n                }else{\n                    left = mid +1;\n                }\n            }\n\n        }\n        return res;\n    }\n}\n\n```",
                                    "expandState": "expand",
                                    "layout": null
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cip62i567o00",
                                    "created": 1647827419827,
                                    "text": "69 x的平方根",
                                    "expandState": "expand",
                                    "layout": null,
                                    "note": "``` java\n\nclass Solution {\n    public int mySqrt(int x) {\n       int low = 0;\n       int high = x;\n       int ans = -1;\n       while(low<=high){\n         int mid = low + (high - low) /2;\n         if ((long)mid * mid<=x){\n             low = mid +1;\n             ans = mid;\n         }else{\n            high = mid -1;\n         }\n       }\n       return ans;\n    }\n}\n\n```",
                                    "progress": 6
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cip62nhhczs0",
                                    "created": 1647827431455,
                                    "text": "367 有效的完全平方根",
                                    "expandState": "expand",
                                    "layout": null,
                                    "note": "```\n\nclass Solution {\n    public boolean isPerfectSquare(int num) {\n        int left = 0;\n        int right = num;\n        while(left<=right){\n            int mid = left + (right - left) /2;\n            if ((long) mid* mid <num){\n                left = mid +1;\n            }else if((long) mid * mid > num){\n                right = mid - 1;\n            }else{\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n```",
                                    "progress": 5
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "ciqx2ft83zc0",
                            "created": 1648005144675,
                            "text": "27 移除元素"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "ciqx2vdb1280",
                                    "created": 1648005178541,
                                    "text": "26 删除排序数组中的重复项",
                                    "note": "```\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int slow = 0;\n        for(int i = 0;i<nums.length;i++){\n            if(nums[slow]!=nums[i]){\n                 slow++;\n                nums[slow] = nums[i];\n               \n            }\n        }\n        return slow+1;\n    }\n}\n\n\n\n```",
                                    "progress": 5
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "ciqx33860f40",
                                    "created": 1648005195645,
                                    "text": "283 移动0"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "ciqx36j7icw0",
                                    "created": 1648005202843,
                                    "text": "844 比较退格的字符串"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "ciqx3htase00",
                                    "created": 1648005227398,
                                    "text": "977 有序数组的平方"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "ciqx43rbp5s0",
                            "created": 1648005275167,
                            "text": "209 长度最小的子数组",
                            "note": "```\n\n\nclass Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int sum = 0;\n        int result = Integer.MAX_VALUE;\n         int left = 0;\n        for(int right = 0;right<nums.length;right++){\n            sum+=nums[right];\n            while(sum>=target){\n                result = Math.min(result,right-left+1);\n                sum = sum - nums[left++];\n            }\n        }\n        return result==Integer.MAX_VALUE?0:result;\n    }\n}\n\n```",
                            "progress": 5
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "ciqx5cm295c0",
                                    "created": 1648005372804,
                                    "text": "904 水果成蓝"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "ciqx5fd27o80",
                                    "created": 1648005378790,
                                    "text": "76 最小覆盖子串"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "ciqx6jujhpc0",
                            "created": 1648005466919,
                            "text": "59 螺旋矩阵"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cip5u7hprfs0",
                    "created": 1647826769728,
                    "text": "链表",
                    "expandState": "expand",
                    "layout": null
                },
                "children": [
                    {
                        "data": {
                            "id": "ciqx7jl4ltc0",
                            "created": 1648005544714,
                            "text": "203 移除链表元素",
                            "note": "```\n\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        ListNode header = new ListNode(-1);\n        header.next = head;\n        ListNode cur = header;\n\n        while(cur.next!=null) {\n            if (cur.next.val==val){\n                cur.next = cur.next.next;\n            }else{\n                cur = cur.next;\n            }\n        }\n\n        return header.next;\n    }\n}\n```",
                            "progress": 5
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "ciqx7o2gprs0",
                            "created": 1648005554469,
                            "text": "707 设计链表"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "ciqx8t4k5kw0",
                            "created": 1648005643844,
                            "text": "206 反转链表",
                            "progress": 5,
                            "note": "```\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode pre = null;\n        ListNode next = null;\n        ListNode cur = head;\n        while(cur!=null){\n            next = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = next;\n        }\n        return pre;\n    }\n}\n```"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "ciqx95d0j5c0",
                            "created": 1648005670477,
                            "text": "25. K 个一组翻转链表",
                            "progress": 5,
                            "note": "```\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        ListNode pre = null;\n        ListNode test = head;\n        ListNode cur = head;\n        ListNode next = null;\n        int canProcess = 0;\n    \n        while(test!=null && canProcess<k){\n            test = test.next;\n            canProcess++;\n        }\n       \n        if(canProcess==k){\n            int lastCount = k;\n            while(cur!=null && lastCount>0 ){\n                next = cur.next;\n                cur.next = pre;\n                pre = cur;\n                cur = next;\n                lastCount--;\n            }\n            head.next = reverseKGroup(next,k);\n\n        }else{\n            return head;\n        }\n        return pre;\n    }\n}\n```"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "ciqxa8rh1940",
                            "created": 1648005756245,
                            "text": "24. 两两交换链表中的节点",
                            "note": "```\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null){\n            return head;\n        }\n        ListNode next = head.next;\n        head.next = swapPairs(next.next);\n        next.next = head;\n        return next;\n\n    }\n}\n```",
                            "progress": 5
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "ciqxagnztcw0",
                            "created": 1648005773449,
                            "text": "19.删除链表的倒数第N个节点",
                            "note": "``` \nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        ListNode fast = dummy;\n        ListNode slow = dummy;\n\n        while(n-->0){\n            fast = fast.next;\n        }\n        ListNode slowPre = null;\n        while (fast!=null){\n            fast = fast.next;\n            slowPre = slow;\n            slow  = slow.next;\n        }\n        slowPre.next = slow.next;\n        return dummy.next;\n\n    }\n}\n```",
                            "progress": 5
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "ciqxb7hamkg0",
                            "created": 1648005831817,
                            "text": "面试题 02.07. 链表相交"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "ciqxbg1wtmw0",
                            "created": 1648005850478,
                            "text": "142.环形链表II",
                            "note": "```\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast!=null && fast.next!=null){\n            fast = fast.next.next;\n            slow = slow.next;\n            if(fast == slow){\n                ListNode index1  = fast;\n                ListNode index2 = head;\n                while(index1!=index2){\n                    index1 = index1.next;\n                    index2  = index2.next;\n                }\n                return index1;\n            }\n        }\n        return null;\n    }\n}\n    ",
                            "progress": 5
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cip5uduvd680",
                    "created": 1647826783584,
                    "text": "哈希表",
                    "expandState": "expand",
                    "layout": null
                },
                "children": [
                    {
                        "data": {
                            "id": "cithri0ta540",
                            "created": 1648266650704,
                            "text": "242 有效的字母异位词",
                            "expandState": "expand",
                            "note": "```\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        if(s.length()!=t.length()){\n            return false;\n        }\n        char[] sArray = s.toCharArray();\n        char[] tArray = t.toCharArray();\n        int[] record  = new int[26];\n        for(int i = 0; i< sArray.length;i++){\n            record[sArray[i]-'a']+=1;\n        }\n        for(int i = 0; i< tArray.length;i++){\n            record[tArray[i]-'a']-=1;\n        }\n         for(int i = 0; i< tArray.length;i++){\n            if (record[tArray[i]-'a']!=0){\n                return false;\n            }\n        }\n        return true;\n        \n\n    }\n}\n```",
                            "progress": 8
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cithrt7wins0",
                                    "created": 1648266675077,
                                    "text": "383 赎金信",
                                    "progress": 6,
                                    "note": "```\nclass Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        int[] record = new int[26];\n        for(int i = 0;i<magazine.length();i++){\n            record[magazine.charAt(i)-'a']+=1;\n        }\n        for(int i = 0 ; i<ransomNote.length();i++){\n            record[ransomNote.charAt(i)-'a']-=1;\n            if(record[ransomNote.charAt(i)-'a']<0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "ciths0w4r480",
                                    "created": 1648266691779,
                                    "text": "49 字母异位词分组",
                                    "progress": 4,
                                    "note": "```\nclass Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        int[] record = new int[26];\n        for(int i = 0;i<magazine.length();i++){\n            record[magazine.charAt(i)-'a']+=1;\n        }\n        for(int i = 0 ; i<ransomNote.length();i++){\n            record[ransomNote.charAt(i)-'a']-=1;\n            if(record[ransomNote.charAt(i)-'a']<0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cithsbz9nvk0",
                                    "created": 1648266715913,
                                    "text": "438 找到字符串中所有字母异位词",
                                    "note": "```\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        int n = s.length(), m = p.length();\n        List<Integer> res = new ArrayList<>();\n        if(n < m) return res;\n\n        int[] pCnt = new int[26];\n        int[] sCnt = new int[26];\n\n        for(int i = 0; i < m; i++){\n            pCnt[p.charAt(i) - 'a'] ++;\n        }\n\n        int left = 0;\n        for(int right = 0; right < n; right++){\n            int curRight = s.charAt(right) - 'a';\n            sCnt[curRight]++;\n            while(sCnt[curRight] > pCnt[curRight]){\n                int curLeft = s.charAt(left) - 'a';\n                sCnt[curLeft]--;\n                left++;\n            }\n            if(right - left + 1 == m){\n                res.add(left);\n            }\n        }\n        return res;\n    }\n}\n\n```",
                                    "progress": 7
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "cithssuiys00",
                            "created": 1648266752632,
                            "text": "349 两个数组的交集",
                            "note": "````\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        if(nums1==null || nums2==null) return null;\n        Set<Integer> set1 = new HashSet<>();\n        Set<Integer> reset = new HashSet<>();\n        for(int i = 0;i<nums1.length;i++){\n            set1.add(nums1[i]);\n        }\n        for(int i = 0;i<nums2.length;i++){\n            if(set1.contains(nums2[i])){\n                reset.add(nums2[i]);\n            }\n        }\n        int[] res = new int[reset.size()];\n        int i = 0;\n        for(Integer item:reset){\n            res[i++]=item;\n        }\n        return res;\n    }\n}\n```",
                            "progress": 5
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cithszx4yqo0",
                                    "created": 1648266768027,
                                    "text": "350 两个数组交集2",
                                    "note": "```\nclass Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        List<Integer> list1 = new ArrayList<>();\n        List<Integer> list2 = new ArrayList<>();\n\n\n        for(int i = 0;i<nums1.length;i++){\n            list1.add(nums1[i]);\n        }\n\n        for(int i=0;i<nums2.length;i++){\n            if(list1.contains(nums2[i])){\n                list1.remove(Integer.valueOf(nums2[i]));\n                list2.add(nums2[i]);\n            }\n        }\n        int[] res = new int[list2.size()];\n        int i = 0;\n        for(Integer s:list2){\n            res[i++] = s;\n        }\n        return res;\n       \n    }\n}\n```",
                                    "progress": 5
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "cithswkppg80",
                            "created": 1648266760746,
                            "text": "202 快乐数",
                            "note": "```\nclass Solution {\n    public boolean isHappy(int n) {\n        HashSet<Integer> set = new HashSet<>();\n        while(n!=1&&!set.contains(n)){\n            set.add(n);\n            n = next(n);\n        }\n        if (n!=1){\n            return false;\n        }\n        return true;\n    }\n\n    public int next(int n){\n        int sum = 0;\n        while(n>0){\n            int m = n%10;\n            n = n/10;\n            sum+=m*m;\n        }\n        return sum;\n    }\n}\n```",
                            "progress": 5
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cithtdg8c7k0",
                            "created": 1648266797480,
                            "text": "1 两数之和",
                            "expandState": "expand",
                            "progress": 5,
                            "note": "# 哈希\n```\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer,Integer>map = new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            if(map.containsKey(target-nums[i])){\n                return new int[]{i,map.get(target-nums[i])};\n            \n            }\n            map.put(nums[i],i);\n        }\n        return new int[2];\n    }\n}\n```\n"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cithtnyy7aw0",
                                    "created": 1648266820380,
                                    "text": "454 四数相加"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cithubvrwo80",
                                    "created": 1648266872431,
                                    "text": "18 四数之和"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "cip5umbsra00",
                    "created": 1647826802022,
                    "text": "字符串",
                    "expandState": "expand",
                    "layout": null
                },
                "children": [
                    {
                        "data": {
                            "id": "cithx9erc540",
                            "created": 1648267102141,
                            "text": "344 反转字符串",
                            "progress": 5,
                            "note": "```\nclass Solution {\n    public void reverseString(char[] s) {\n        int i=0,j=s.length-1;\n        while(i<j){\n            char tmp = s[i];\n            s[i] = s[j];\n            s[j]=tmp;\n            i++;\n            j--;\n        }\n    }\n}\n\n```"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cithxd76t4w0",
                            "created": 1648267110390,
                            "text": "541 反转字符串2",
                            "progress": 5,
                            "note": "```\nclass Solution {\n   public String reverseStr(String s, int k) {\n        char[] ch = s.toCharArray();\n        for(int i = 0; i < ch.length; i += 2 * k){\n            int start = i;\n            //这里是判断尾数够不够k个来取决end指针的位置\n            int end = Math.min(ch.length - 1, start + k - 1);\n            //用异或运算反转 \n            while(start < end){\n                ch[start] ^= ch[end];\n                ch[end] ^= ch[start];\n                ch[start] ^= ch[end];\n                start++;\n                end--;\n            }\n        }\n        return new String(ch);\n    }\n}\n```"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cithxl41uog0",
                            "created": 1648267127614,
                            "text": "剑指offer 05  替换空格",
                            "progress": 9,
                            "note": "```\nclass Solution {\n    public String replaceSpace(String s) {\n        int len = s.length();\n        StringBuilder sb = new StringBuilder();\n\n        for(int i=0;i<len;i++){\n            char c = s.charAt(i);\n            if (c==' ' ){\n                sb.append(\"%20\");\n            }else{\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}\n\n```"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cithxn7fo5k0",
                            "created": 1648267132173,
                            "text": "反转字符串中的单词",
                            "progress": 5,
                            "note": "```\nclass Solution {\n   public String reverseWords(String s) {\n\tString[] strs = s.split(\" \");\n\tStringBuffer buffer = new StringBuffer();\n\tfor (int i = 0; i < strs.length; i++) {\n\t\tbuffer.append(new StringBuffer(strs[i]).reverse().toString());\n\t\tbuffer.append(\" \");\n\t}\n\treturn buffer.toString().trim();\n    }\n}\n\n```"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cithxsvt6wo0",
                            "created": 1648267144530,
                            "text": "左旋转字符串"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cithxvlmvmw0",
                            "created": 1648267150446,
                            "text": "实现strstr"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cithxyob51c0",
                            "created": 1648267157138,
                            "text": "重复的子字符串"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cip5uoak8wg0",
                    "created": 1647826806300,
                    "text": "双指针",
                    "expandState": "expand",
                    "layout": null
                },
                "children": [
                    {
                        "data": {
                            "id": "cithtsr66pk0",
                            "created": 1648266830793,
                            "text": "15 三数之和",
                            "progress": 5,
                            "note": "```\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        int len = nums.length;\n        Arrays.sort(nums);\n        for(int i = 0;i<len-2;++i){\n            if(i==0 || i>0 && nums[i]!=nums[i-1]){\n                int l = i+1;\n                int r = len-1;\n                while(l<r){\n                    if(nums[i]+nums[l]+nums[r]>0){\n                        while(l<r && nums[r]==nums[r-1]){\n                            r--;\n                        }\n                        r--;\n                    }else if(nums[i]+nums[l]+nums[r]<0){\n                        while(l<r && nums[l]==nums[l+1]){\n                            l++;\n                        }\n                        l++;\n                    }else{\n                        res.add(Arrays.asList(nums[i],nums[l],nums[r]));\n                         while(l<r && nums[r]==nums[r-1]){\n                            r--;\n                        }\n                         while(l<r && nums[l]==nums[l+1]){\n                            l++;\n                        }\n                        l++;\n                        r--;\n                    }\n                   \n                }\n            }\n        }\n        return res;\n    }\n}\n```"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cip5uqhal800",
                    "created": 1647826811061,
                    "text": "栈与队列",
                    "expandState": "expand",
                    "layout": null
                },
                "children": []
            },
            {
                "data": {
                    "id": "cip5v0wfbps0",
                    "created": 1647826833744,
                    "text": "二叉树",
                    "expandState": "expand",
                    "layout": null
                },
                "children": [
                    {
                        "data": {
                            "id": "citr045fwe80",
                            "created": 1648292715775,
                            "text": "基础"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "citr0amzkr40",
                                    "created": 1648292729897,
                                    "text": "二叉树理论基础"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "citr0edif0w0",
                                    "created": 1648292738031,
                                    "text": "二叉树的递归遍历"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "citr0ideknk0",
                                    "created": 1648292746731,
                                    "text": "二叉树的迭代遍历"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "citr0ogz7q80",
                                    "created": 1648292760008,
                                    "text": "二叉树的层序遍历"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "citr0vlfzxc0",
                            "created": 1648292775516,
                            "text": "226 反转二叉树",
                            "note": "```\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if (root == null ) return null;\n        TreeNode rightTree = root.right;\n        root.right = invertTree(root.left);\n        root.left = invertTree(rightTree);\n        return root;\n    }\n}\n```",
                            "progress": 5
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr16hi1co0",
                            "created": 1648292799222,
                            "text": "101 对称二叉树",
                            "note": "```\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if (root == null) return true;\n        return check(root.left,root.right);\n    }\n    public boolean check(TreeNode left,TreeNode right){\n        if(left==null&&right==null) return true;\n        if(left==null || right == null || left.val!=right.val) return false;\n        return check(left.left,right.right) && check(left.right,right.left);\n    }\n}\n```",
                            "progress": 5
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr1h3hg4w0",
                            "created": 1648292822319,
                            "text": "104 二叉树的最大深度",
                            "progress": 5,
                            "note": "```\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        // 空树，高度为 0\n        if(root == null){\n            return 0;\n        }\n        // 初始化队列和层次\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int depth = 0;\n\n        // 当队列不为空\n        while(!queue.isEmpty()){\n            // 当前层的节点数\n            int n = queue.size();\n            // 弹出当前层的所有节点，并将所有子节点入队列\n            for(int i = 0; i < n; i++){\n                TreeNode node = queue.poll();\n                if(node.left != null){\n                    queue.offer(node.left);\n                }\n                if(node.right != null){\n                    queue.offer(node.right);\n                }\n            }\n            depth++;\n        }\n        // 二叉树最大层次即为二叉树最深深度\n        return depth;\n    }\n}\n```"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr1tsvn340",
                            "created": 1648292849976,
                            "text": "111 二叉树的最小深度",
                            "note": "```\nclass Solution {\n    public int minDepth(TreeNode root) {\n        if (root  == null ) {\n            return 0 ;\n        }\n        if (root.left == null && root.right != null) {\n            return 1+ minDepth(root.right);\n        }\n        if (root.left != null && root.right ==null){\n            return 1 + minDepth(root.left);\n        }\n        return 1+ Math.min(minDepth(root.left),minDepth(root.right));\n    } \n}\n```",
                            "progress": 6
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr23zym4g0",
                            "created": 1648292872172,
                            "text": "222 完全二叉树的节点个数",
                            "note": "```\nclass Solution {\n    public int countNodes(TreeNode root) {\n        if(root==null) return 0;\n        int count = 0;\n        TreeNode left = root.left;\n        TreeNode right = root.right;\n\n        if(left!=null){\n            count += countNodes(left);\n        }\n        if (right!=null){\n            count += countNodes(right);\n        }\n        return count+1;\n    }\n}\n```",
                            "progress": 8
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr2euavv40",
                            "created": 1648292895774,
                            "text": "110平衡二叉树",
                            "note": "```\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        if (root == null)  return true;\n\n        TreeNode left = root.left;\n        TreeNode right = root.right;\n        if(Math.abs(maxDepth(left)-maxDepth(right))>1){\n            return false;\n        }else{\n            return isBalanced(left) && isBalanced(right);\n        }\n        \n    }\n\n    public int maxDepth(TreeNode root){\n        return root==null?0:Math.max(maxDepth(root.left),maxDepth(root.right))+1;\n    }\n}\n```",
                            "progress": 7,
                            "resource": [
                                "👌"
                            ]
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr2rfl5r40",
                            "created": 1648292923183,
                            "text": "257 二叉树的所有路径",
                            "note": "```\nclass Solution {\n\n    List<String> res  = new ArrayList<>();\n    public List<String> binaryTreePaths(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        List<String> list = new ArrayList<>();\n        dfs(list,sb,root);\n        return list;\n    }\n\n    public void dfs(List<String> res,StringBuilder sb,TreeNode root){\n        if (root == null) return;\n        if (root.left==null && root.right==null){\n            res.add(sb.append(root.val).toString());\n        }\n        sb.append(root.val).append(\"->\");\n        dfs(res,new StringBuilder(sb.toString()),root.left);\n        dfs(res,new StringBuilder(sb.toString()),root.right);\n    }\n}\n```",
                            "progress": 5
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr3ai3p2g0",
                            "created": 1648292964694,
                            "text": "404 左叶子之和",
                            "note": "```\nclass Solution {\n    int sum = 0;\n    public int sumOfLeftLeaves(TreeNode root) {\n        sum(root);\n        return sum;\n    }\n\n    public void sum(TreeNode root){\n        if (root == null){\n            return;\n        }\n        if (root.left!=null&&root.left.left==null&&root.left.right==null){\n            sum+=root.left.val;  \n        }\n         sum(root.left);\n        sum(root.right);\n    }\n}\n```",
                            "progress": 5
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr3w6s01s0",
                            "created": 1648293011898,
                            "text": "513 找树左下角的值",
                            "progress": 4,
                            "note": "```\nclass Solution {\n\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()){\n            root = queue.poll();\n            if(root.right!=null) queue.offer(root.right);\n            if(root.left!=null) queue.offer(root.left);\n        }\n        return root.val;\n    }\n    \n}\n```"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr46bt6j40",
                            "created": 1648293033970,
                            "text": "112 路径之和",
                            "note": "```\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if(root==null){\n            return false;\n\n        }\n        if(root.left==null && root.right ==null){\n            return sum-root.val == 0;\n        }\n        return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);\n    }\n}\n```",
                            "progress": 4
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr4ezu0jk0",
                            "created": 1648293052837,
                            "text": "106 从中序和后序遍历序列构造二叉树"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr4t7h04g0",
                            "created": 1648293083774,
                            "text": "654 最大二叉树"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr50qmzv40",
                            "created": 1648293100170,
                            "text": "617 合并二叉树"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr55o0s680",
                            "created": 1648293110896,
                            "text": "700 二叉搜索树中的搜索"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr5g8smjc0",
                            "created": 1648293133920,
                            "text": "98 验证二叉搜索树"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr5lwv2eg0",
                            "created": 1648293146259,
                            "text": "530 二叉搜索树的最小绝对差"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr60x6vfk0",
                            "created": 1648293178931,
                            "text": "501 二叉搜索树的众数"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr6bqlzfc0",
                            "created": 1648293202477,
                            "text": "236 二叉搜索树的最近公共祖先"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr6i2dsx40",
                            "created": 1648293216250,
                            "text": "701 二叉搜索树中的插入操作"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr7saaee80",
                            "created": 1648293316860,
                            "text": "450 删除二叉搜索树中的节点"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr80q8g2g0",
                            "created": 1648293335238,
                            "text": "108 将有序数组转换为二叉搜索树"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "citr8ka0ghs0",
                            "created": 1648293377793,
                            "text": "538 把二叉搜索树转换为累加树"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cip5vaus4i00",
                    "created": 1647826855412,
                    "text": "回溯算法",
                    "expandState": "expand",
                    "layout": null,
                    "note": "```\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    LinkedList<Integer> path = new LinkedList<>();\n    public List<List<Integer>> combine(int n, int k) {\n        combineHelper(n, k, 1);\n        return result;\n    }\n\n    /**\n     * 每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex\n     * @param startIndex 用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,...,n] ）。\n     */\n    private void combineHelper(int n, int k, int startIndex){\n        //终止条件\n        if (path.size() == k){\n            result.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++){\n            path.add(i);\n            combineHelper(n, k, i + 1);\n            path.removeLast();\n        }\n    }\n}\n```"
                },
                "children": [
                    {
                        "data": {
                            "id": "ciwcvaww83s0",
                            "created": 1648557523006,
                            "text": "77 组合",
                            "progress": 5,
                            "note": "```\nclass Solution {\n\n    List<List<Integer>> result = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n    public List<List<Integer>> combine(int n, int k) {\n        backtracing(n,k,1);\n        return result;\n    }\n\n    void backtracing(int n,int k,int startIndex){\n        if (path.size()==k){\n            result.add(new ArrayList(path));\n\n            return;\n        }\n        for(int i = startIndex;i<=n-(k-path.size())+1;i++){\n        \n            path.add(i);\n            backtracing(n,k,i+1);\n            path.remove(path.size()-1);\n        }\n    }\n}\n```"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "ciwcvdt9cjc0",
                            "created": 1648557529317,
                            "text": "216. 组合总和 III",
                            "progress": 3,
                            "note": "```\nclass Solution {\n    List<List<Integer>> result = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        backtracking(k,n,1);\n        return result;\n    }\n    public void backtracking(int k,int sum,int startIndex){\n        if(sum < 0)return;\n        if(path.size() == k){\n           if(sum == 0)result.add(new ArrayList(path));\n            return;\n        }\n        for(int i = startIndex;i <= 9 - (k - path.size()) + 1;i++){\n            sum -= i;\n            path.add(i);\n            backtracking(k,sum,i + 1);\n            sum += i;\n            path.remove(path.size() - 1);\n        }\n    }\n\n}\n```"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "ciwcvg4ryw00",
                            "created": 1648557534367,
                            "text": "17 电话号码和字母组合",
                            "note": "```\nclass Solution {\n    String[] wordsMap = {\" \",\"*\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        List<String> res = new ArrayList<>();\n\n        public List<String> letterCombinations(String digits) {\n            if(digits==null || digits.length()==0){\n                return res;\n            }\n            iterStr(digits,new StringBuilder(),0);\n            return res;\n        }\n\n        public void iterStr(String str, StringBuilder letter, int index) {\n            if(index==str.length()){\n                res.add(letter.toString());\n                return;\n            }\n            String worsString=wordsMap[str.charAt(index)-'0'];\n            for(int i=0;i<worsString.length();i++){\n                letter.append(worsString.charAt(i));\n                iterStr(str,letter,index+1);\n                letter.deleteCharAt(letter.length()-1);\n            }\n        }\n\n}\n```",
                            "progress": 5
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "ciwcvk5eeao0",
                            "created": 1648557543111,
                            "text": "39 组合总和",
                            "note": "```\nclass Solution {\n\n    List<List<Integer>> res = new ArrayList<>();\n    List<Integer> path = new ArrayList<>();\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        backtracing(candidates,target,0);\n        return res;\n    }\n\n    public void backtracing(int[] candidates,int target,int startIndex){\n        if(target<0){\n            return;\n        }\n        if(target == 0){\n            res.add(new ArrayList(path));\n            return;\n        }\n        for(int i = startIndex;i<candidates.length;i++){\n            path.add(candidates[i]);\n            backtracing(candidates,target-candidates[i],i);\n            path.remove(path.size()-1);\n        }\n\n    }\n}\n```",
                            "progress": 5
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "ciwcvp9y70o0",
                            "created": 1648557554270,
                            "text": "组合总数2"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "ciwcvqy69yw0",
                            "created": 1648557557912,
                            "text": "分割回文串"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "ciwcvxkf0e80",
                            "created": 1648557572318,
                            "text": "复原ip地址"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "ciwcw2ivk8w0",
                            "created": 1648557583108,
                            "text": "子集问题"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cip5vd7f1yw0",
                    "created": 1647826860530,
                    "text": "贪心算法",
                    "expandState": "expand",
                    "layout": null
                },
                "children": [
                    {
                        "data": {
                            "id": "cj1yvsfwqmo0",
                            "created": 1649127425362,
                            "text": "分发饼干"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1yvwy5rao0",
                            "created": 1649127435173,
                            "text": "最大子序和"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1yw6ip5aw0",
                            "created": 1649127456006,
                            "text": "买卖股票的最佳时机2"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1ywbh2ryg0",
                            "created": 1649127466792,
                            "text": "跳跃游戏"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1ywff39ns0",
                            "created": 1649127475379,
                            "text": "跳跃游戏2"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1ywhlcbcw0",
                            "created": 1649127480110,
                            "text": "k次取反后最大化的数组和"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1ywrifbdc0",
                            "created": 1649127501702,
                            "text": "加油站"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1ywtho07k0",
                            "created": 1649127506010,
                            "text": "柠檬水找零"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1ywxb99m80",
                            "created": 1649127514329,
                            "text": "根据身高重建队列"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1yx1r3xps0",
                            "created": 1649127523995,
                            "text": "用最少数量的箭引爆气球"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1yx9tx2co0",
                            "created": 1649127541579,
                            "text": "无重叠区域"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1yxbsj6e80",
                            "created": 1649127545849,
                            "text": "划分字母区间"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1yxkbnrrk0",
                            "created": 1649127564420,
                            "text": "单调递增的数字"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1yxvh4vqo0",
                            "created": 1649127588695,
                            "text": "买卖股票的最佳时机含手续费"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1yy59gt9s0",
                            "created": 1649127609999,
                            "text": "监控二叉树"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cip5vlfnusw0",
                    "created": 1647826878443,
                    "text": "动态规划",
                    "expandState": "expand",
                    "layout": null
                },
                "children": [
                    {
                        "data": {
                            "id": "cj1yydy7ezc0",
                            "created": 1649127628909,
                            "text": "斐波那些数列"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1yyjto4ow0",
                            "created": 1649127641696,
                            "text": "爬楼梯"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1yylgxotk0",
                            "created": 1649127645279,
                            "text": "使用最小花费爬楼梯"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1yzc8uao80",
                            "created": 1649127703563,
                            "text": "不同路径"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1yzeozg0g0",
                            "created": 1649127708893,
                            "text": "不同路径2"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1yzgnz90o0",
                            "created": 1649127713186,
                            "text": "整数拆分"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1yzkpx2ao0",
                            "created": 1649127722010,
                            "text": "不同的二叉搜索树"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1yzqjjboo0",
                            "created": 1649127734685,
                            "text": "背包理论基础"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1yzv27c3c0",
                            "created": 1649127744521,
                            "text": "分割等和子集"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z0170fu00",
                            "created": 1649127757872,
                            "text": "最后一块石头的重量"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z07woi0w0",
                            "created": 1649127772485,
                            "text": "目标和"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z09i2muw0",
                            "created": 1649127775955,
                            "text": "一和零"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z0lion2o0",
                            "created": 1649127802114,
                            "text": "完全背包理论基础"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z0puatvc0",
                            "created": 1649127811523,
                            "text": "两千兑换2"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z0rxgrnc0",
                            "created": 1649127816068,
                            "text": "组合总和4"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z0xutujs0",
                            "created": 1649127828969,
                            "text": "爬楼梯"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z12j743s0",
                            "created": 1649127839150,
                            "text": "零钱兑换"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z143qzeg0",
                            "created": 1649127842569,
                            "text": "完全平方数"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z164vf8g0",
                            "created": 1649127846991,
                            "text": "单词拆分"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z1axnn8o0",
                            "created": 1649127857438,
                            "text": "多重背包理论"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z1eavths0",
                            "created": 1649127864769,
                            "text": "打家劫舍"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z1hewdmw0",
                            "created": 1649127871542,
                            "text": "打家劫舍2"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z1j9b4j40",
                            "created": 1649127875557,
                            "text": "打家劫舍3"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z1l03gp40",
                            "created": 1649127879354,
                            "text": "买卖股票的最佳时机"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z1oxikrk0",
                            "created": 1649127887905,
                            "text": "最长上升子序列"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z1v42uf40",
                            "created": 1649127901362,
                            "text": "最长连续递增序列"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z241raw00",
                            "created": 1649127920813,
                            "text": "最长公共子序列"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z1zr6nbs0",
                            "created": 1649127911467,
                            "text": "不想交的线"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z27ep4rk0",
                            "created": 1649127928126,
                            "text": "判断子序列"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z2fk5y0o0",
                            "created": 1649127945871,
                            "text": "两个字符串的删除操作"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z2j3ppqw0",
                            "created": 1649127953583,
                            "text": "编辑距离"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z2lcjqs00",
                            "created": 1649127958471,
                            "text": "回文字符串"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cj1z2op72m00",
                            "created": 1649127965766,
                            "text": "最长回文子序列"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cip5vrt3jlk0",
                    "created": 1647826892316,
                    "text": "单调栈",
                    "expandState": "expand",
                    "layout": null
                },
                "children": []
            }
        ]
    },
    "template": "default",
    "theme": "classic-compact",
    "version": "1.4.43"
}